# 8. HTTP 2 的世界（校对 1）

那么当 HTTP 2 被广泛采用的时候，世界会成怎么样呢？或者它会被广泛采用吗？

**8.1. HTTP 2 会如何影响普通人？**

现在 HTTP 2 还没被大范围部署使用，我们也无法确定到底会发生什么变化，但至少可以参考 SPDY 的例子和曾经做过的实验来进行大概估计。

HTTP 2 减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免了 Head of line blocking 的困扰。

它也支持大量并行流，所以即使网站的数据分发在各处也不是问题。

合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。

所有这些加起来，我认为页面载入时间和站点相应的速度都会更快。简而言之：更好的 Web 体验。

但到底能变得多快，到底提升有多大呢？我认为目前很难说清楚。毕竟这些技术依然在早期，我们还没发看见客户端和服务器实现这些并真正受益于新协议所提供的强大功能。

**8.2. HTTP 2 会如何影响 Web 开发？**

近年来，Web 开发者、Web 开发环境为一些 HTTP 1.1 的问题提供了临时解决方案。不妨回忆一下，其中一些我已在上文中简单的介绍了。

这些解决方案很多是工具和开发者默认使用的，这很可能会损害到 HTTP 2 的性能，或者至少让我们没法真正利用到 HTTP 2 新的强大威力。Spriting 和内联应该是 HTTP 2 里面最不需要的了。因为 HTTP 2 更倾向于使用更少的连接，所以 Sharding 甚至会伤害到 HTTP 2 的性能。

这里的问题就是：Web 网站和 Web 开发们至少在短期内需要同时支持 HTTP 1.1 和 HTTP 2 的客户端。否则的话，使所有用户获得最好的体验将是一个挑战。

考虑到这些问题，我认为距离 HTTP 2 的潜力被彻底发掘还有很长一段路要走。

**8.3. HTTP 2 的实现**

在这样一篇文章中详细说明每个实现细节注定乏味且毫无意义，我将用更广泛的术语解释实际场景，给大家提供一个 HTTP 2 的[实现列表](https://github.com/http2/http2-spec/wiki/Implementations)作为参考。

在 HTTP 2 的早期就已经有大量的实现。并且在 HTTP 2 标准化工作期间，这个数量还持续增长。截至我写这篇文档的时候，共有30种实现记录在案，他们中的大多数都实现了最新的草案。

Firefox 一直紧跟最新的协议，Twitter 也紧追不舍提供了基于 HTTP 2 的服务。2014 年 4 月期间，Google 在少数测试服务器上提供 HTTP 2 支持。从同年 5 月开始，开发版的 Chrome 支持 HTTP 2 。Microsoft 也在他们的产品预发布会上展示了支持 HTTP 2 的下一代浏览器。

curl 和 libcurl 支持未加密的 HTTP 2 ，同时借助某些 TLS 库支持了 TLS。

draft-17 是当前最新的草案版本，它二进制兼容 draft-14，后者是最近一个被标记为 implementation/interop 的草案。但是当 draft-17 进行线上二进制兼容的时候，草案的语言的改变也造成了他们的些许不同。<!-- 这段需要review --><!-- reviewed by @Jury_Xiong -->

**8.3.1. 缺失的实现**

现有的实现列表中仍然有明星品牌缺席。目前尚未听到 Apple 官方有让 Safari 支持 HTTP 2 的计划。Apache HTTPD 和 Nginx 这两大流行的服务器都提供 SPDY 的支持，但却没有对提供 HTTP 2 的支持进行任何表态。

Nginx表示「我们计划于 2015 年末发布带有 HTTP/2 支持的 Nginx 和 Nginx Plus」。而 Apache 已经有一个非常早期的 HTTP/2 模块，叫作[mod_h2](https://icing.github.io/mod_h2/)。

**8.4. 对 HTTP 2 的常见批评**

在制定协议的讨论过程中有许多充满争议的地方，甚至会有不少人认为这样的协议最终会以失败告终。这里我想提一些对协议常见的批评和我的解释：

**8.4.1. 「这个协议是 Google 设计制定的」**

江湖上有太多传言暗示着这个世界越来越被 Google 所控制，但事实显然不是这样。这个协议是 IETF 制定的，就跟过去 30 年间很多其他协议一样。但不得不承认，SPDY 是 Google 非常出色的成果。它不仅仅证明了开发一个新协议的可行性，还充分展现了新协议能带来的好处。

Google 公开[声明](http://blog.chromium.org/2015/02/hello-http2-goodbye-spdy-http-is_9.html)了他们会在 2016 年移除 Chrome 里对 SPDY 和 NPN 的支持，并且极力推动服务器迁移至 HTTP/2。

**8.4.2. 「这个协议只在浏览器上有用」**

在某种程度上，这是对的。开发 HTTP 2 的一个主要动机就是修复 HTTP pipelining。如果在你的应用场景里本来就不需要 pipelining，那么确实很有可能 HTTP 2 对你没有太大帮助。虽然这并不是唯一的提升，但显然这是非常重要的一个。

一旦当某些服务意识到在一个连接上建立多路复用流的强大威力时，我认为会有越来越多的程序采用 HTTP 2 。

小规模的 REST API 和采用 HTTP 1.x 的简单程序可能不会认为迁移到 HTTP 2 能有多大的优势。但至少 HTTP 2 对绝大部分用户来讲，是几乎没有坏处的。

**8.4.3. 「这个协议只对大型网站有用」**

完全不是这样。因为缺乏内容分发网络，小网站的网络延迟往往较高，而多路复用的能力可以极大的改善在高网络延迟下的体验。大型网站往往已经将内容分发到各处，所以速度其实更快。

**8.4.4. 「TLS 让速度变得更慢」**

这个评价在某种程度上是对的。虽然TLS的握手确实增加了额外的开销，但也有越来越多的方案来减少TLS往返的时间。使用 TLS 而不是纯文本带来的开销是显著的，有可观证据表明，和传输同样的流量相比，TLS 会消耗更多的 CPU 和其他资源。具体影响有多大以及怎么影响是一个和具体测量有关的课题。更多的例子可以参看[istlsfastyet.com](http://istlsfastyet.com)。

Telecom 和一些其他网络服务商，例如 ATIS 开放网络联盟，表示为了为卫星、飞机等提供的快速网络体验，他们需要一些[不加密的流量](http://www.atis.org/openweballiance/docs/OWAKickoffSlides051414.pdf )来提供 caching，压缩和其他技术。

HTTP 2 并不强制要求使用 TLS，所以我们不应该为此担心。

如今，很多互联网使用者已经更希望 TLS 能被更广泛的使用来保护用户隐私。

实验也证明了通过使用 TLS 能比用在 80 端口实现一个新的基于文本的协议更容易成功。因为当前已经有太多中间商使用该方案，所以凡是基于 80 端口的协议，都很可能被理所当然的当作 HTTP 1.1。

最后，得益于 HTTP 2 在单一连接上提供的多路复用流，普通浏览器的正常使用也可以减少 TLS 握手的次数，所以使用 HTTPS 仍然会比 HTTP 1.1 更快。

**8.4.5. 「不基于 ASCII 是没法忍受的」**

是的，当我们可以直接「读」到协议的时候，调试和追踪都会变得更简单。但基于文本的协议更容易产生错误，造成更多解析的问题。

如果你真的无法接受二进制协议，那么你也无法在 HTTP 1.x 中处理 TLS 和压缩。而这些其实已经被使用了很久了。

**8.4.6. 「它根本没有比 HTTP/1.1 快」**

当然，到底该如何定义和测量「快」就是另外一个话题了，但在 SPDY 的时代，已经有一些实验证明了该协议会让浏览器载入页面更快（例如华盛顿大学的「[SPDY 有多快？](https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-wang_xiao_sophia.pdf)」和 Hervé Servy 的「[评估启用 SPDY 的 Web 服务器性能](http://www.neotys.com/blog/performance-of-spdy-enabled-web-servers/)」）。同样，这些实验也被用来证明 HTTP 2 。我期待能有越来越多的测试实验发布。[httpwatch.com](http://blog.httpwatch.com/2015/01/16/a-simple-performance-comparison-of-https-spdy-and-http2/)也有进行一个简单的测试来证明 HTTP/2 名副其实。

HTTP 2 在很多的场景下都证明了自己更快，包含非常多资源的高延迟的连接上。而正如之前的章节中提到，目前的趋势就是每个网站包含越来越多的资源和数据。

**8.4.7. 「它违反了网络分层」**

你是认真的么？网络分层并不是不可侵犯的。如果我们在指定 HTTP 2 的时候已经踏入了灰色地带，那我们当然可以尝试在限制内制定出更好更高效的协议。


**8.4.8. 「它没有修复一些HTTP/1.1的问题」**

确实是这样。兼容 HTTP/1.1 的范式是我们的目标之一，所以一些老的 HTTP 功能仍然被保留。利用一些常用的协议头、可怕的 cookies、验证头等等。但保留这些范式的好处就是我们在升级到新协议的时候少掉很多工作，也不需要重写很多底层的东西。HTTP 2 更多是一个新的帧层。

**8.5. HTTP 2 会被广泛部署吗？**

现在还言之尚早，但我仍然要在这里做出我的预估。

很多怀疑论者会以「看看 IPv6 现在的德性」为例子来试图说明这个经历了 10 多年才开始慢慢被采用的协议。但 HTTP 2 毕竟不是 IPv6。他是一个建立在 TCP 之上的使用 HTTP 更新机制、端口号和 TLS 等的协议。大部分路由器或者防火墙不需要为此而进行更改。

Google 向世界证明了他们的 SPDY，证明了像这样的新协议也能在足够短的时间内拥有多种实现并且能被浏览器和服务所采用。虽然如今支持 SPDY 服务器端数量在 1% 以内，但这些服务器所交换的数据却要大很多。一些最流行的网站现在也有提供 SPDY 支持。

我认为建立在 SPDY 的基本范式之上的 HTTP 2 会被更广泛的部署，毕竟它是 IETF 制定的协议。因为 SPDY 背负了「它是 Google 的协议」这个恶名，所以它的发展总是畏首畏脚。

在首次发布的幕后有很多大型浏览器。来自 Firefox，Chrome 和 IE 的代表宣布了他们会发布支持 HTTP 2 特性的浏览器，并且他们已经演示了一些能正常运作的实现。

也有很多公司，像 Google，Twitter 和 Facebook 希望尽快支持 HTTP 2 ，所以我们可以期待着很快能有支持 HTTP 2 的服务器，例如 Apache HTTP Server 和 Nginx。[H2o](https://github.com/h2o/h2o) 作为一个极有潜力的新生 HTTP 服务器，也同样支持 HTTP 2 。

那些大型代理服务器开发商，例如 HAProxy、Squid 和 Varnish 也表示出了他们对支持 HTTP 2 的兴趣。

我也相信一旦规范被 RFC 批准，会有更多的实现雨后春笋般的涌现出来。

在 2015 年 1 月下旬，默认启用 HTTP/2 的 Firefox 35 发布后，Google 也宣布 Chrome 40 对 2% 的用户启用了该功能。虽然他没有告诉我们具体的数字，但 HTTP/2 已经差不多占到了他们全球流量的 5%。与此同时，Firefox 35 记录到了 9% 的响应都是 HTTP/2。
